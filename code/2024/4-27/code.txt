----------music.py----------

import requests
import jsonpath
import re

def song_download(url, title, author):
    print("True")
    path = '{}.mp3'.format(title)
    print('歌曲:{0}-{1},正在下载...'.format(title, author))
    # 下载(这种适合少量文件下载)
    content = requests.get(url).content
    cleaned_title = clean_filename(title)
    cleaned_author = clean_filename(author)
    with open(file=cleaned_title + cleaned_author + '.mp3', mode='wb') as f:
        f.write(content)
    print('下载完毕,{0}-{1},请试听'.format(title, author))


def clean_filename(filename):
    cleaned_filename = re.sub(r'[^\w-]', '', filename)
    return cleaned_filename


def get_music_name():
    while True:
        print('---------------------------------------------------------')
        print("请合理使用本程序,作者不对任何使用者负责\n下载的音乐无法打开则表示目前没有办法直接下载该音乐!")
        name = input("请输入歌曲名称:")
        print("1.网易云-netease\n2.QQ-qq\n3.酷狗-kugou\n4.酷我-kuwo\n5.百度-baidu\n6.喜马拉雅-ximalaya")
        print("您应当输入netease、qq、kugou、kuwo、baidu、ximalaya中的一个")
        platform = input("请输入音乐平台类型:")
        print("---------------------------------------------------------")
        url = 'https://music.liuzhijin.cn/'
        headers = {
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36",
            "x-requested-with": "XMLHttpRequest",
        }
        param = {
            "input": name,
            "filter": "name",
            "type": platform,
            "page": 1,
        }
        res = requests.post(url=url, data=param, headers=headers)
        json_text = res.json()

        title = jsonpath.jsonpath(json_text, '$..title')
        author = jsonpath.jsonpath(json_text, '$..author')
        url = jsonpath.jsonpath(json_text, '$..url')
        if title:
            songs = list(zip(title, author, url))
            for i, s in enumerate(songs):
                print(f"{i + 1}. {s[0]} - {s[1]}")
            print("---------------------------------------------------------")
            index = int(input("请输入您想下载的歌曲序号(输入0退出):"))
            if index == 0:
                input("输入任意键退出...")
                exit()
            song_download(url[index - 1], title[index - 1], author[index - 1])
        else:
            print("对不起,暂无搜索结果!")

if __name__ == "__main__":
    get_music_name()


----------music.py----------

----------netease-music.py----------

import requests #请求模块 用Python模拟浏览器向服务器发起请求
from bs4 import BeautifulSoup #在html提取数据

#1.确定 获取网址
print('注:如果您的网址格式为:https://music.163.com/#/discover/toplist\n那么删去其中的"/#"部分,使其变为:https://music.163.com/discover/toplist')
print('请合理使用本程序,作者不对任何使用者负责\n下载的音乐无法打开则表示目前没有办法直接下载该音乐!')
print('-----------------------------')
url = input('请输入网址:')
eval("url")
print('-----------------------------')
#2.发送请求
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'
}
res = requests.get(url=url,headers=headers)
#3.筛选数据  xpath  re json bs4 pyquery
#数据预处理   获取整体界面
soup = BeautifulSoup(res.text,'html.parser')
#匹配对应的数据,音乐名称
result = soup.find('ul',class_='f-hide')
infor = result.find_all('a')

idlist = []  #存放ID
namelist = [] #存放名字
number = 0 #歌曲的序号

for i in infor:
    number = number+1
    name = i.text #音乐名字
    # <a href="/song?id=1917957092">爱</a>
    result = i.get('href')
    #result结果就是href后边的数据值
    #/song?id=1917957092
    id = result[9:]
    idlist.append(id)
    Newurl = 'https://music.163.com/'+result
    namelist.append(name)
    print(str(number)+' '+name+' '+Newurl)



#4.保存数据 ()[]{}
def download():
    while True:
        a = input("请输入你要下载的歌曲的序号:")
        b = int(a)-1
        aa = idlist[b]
        musicName = namelist[b]

        url = 'http://music.163.com/song/media/outer/url?id={}.mp3'.format(aa)
        music = requests.get(url=url,headers=headers).content

        with open('{}.mp3'.format(musicName),'wb')as f:
            f.write(music)
            print(musicName+'下载完毕!')

download()

----------netease-music.py----------

----------photo.py----------

from PIL import Image
import os

def convert_images_in_folder(input_folder, output_folder, input_format, output_format):
    for filename in os.listdir(input_folder):      
        if filename.endswith(input_format):
            input_path = os.path.join(input_folder, filename)
            img = Image.open(input_path)
            img = img.convert("RGB")  # 将图像转换为不带Alpha通道的RGB模式
            output_filename = os.path.splitext(filename)[0] + '.' + output_format
            output_path = os.path.join(output_folder, output_filename)
            img.save(output_path, format=output_format.lower(), quality=100, subsampling=0)
            print(f"成功转换 {filename} 的格式为 {output_format}")
    print("转换完成!")  # 循环结束后打印转换完成提示

# 提示用户输入所需的参数
input_folder = input("请输入输入文件夹路径(例如:C:\\Users\\example\\Desktop\\dds):")
output_folder = input("请输入输出文件夹路径(例如:C:\\Users\\example\\Desktop\\png):")

# 如果指定的输出文件夹不存在，则创建该文件夹
if not os.path.exists(output_folder):
    os.makedirs(output_folder)
    print(f"文件夹 {output_folder} 不存在，已创建文件夹")
else:
    print(f"文件夹 {output_folder} 已存在")

input_format = input("请输入输入图像格式(例如:dds):")
output_format = input("请输入输出图像格式(例如:jpeg):")

# 执行转换
print('开始转换...')
convert_images_in_folder(input_folder, output_folder, input_format, output_format)

input("程序执行完毕，按任意键退出...")
exit()

----------photo.py----------

----------search.py----------

import os
import chardet

def read_text_file(file_path, encoding):
    if encoding:
        with open(file_path, 'r', encoding=encoding, errors='replace') as file:
            return file.readlines()
    else:
        with open(file_path, 'r', errors='replace') as file:
            return file.readlines()

def is_text_file(file_path):
    try:
        with open(file_path, 'rb') as file:
            raw_data = file.read(1024)
            encoding = chardet.detect(raw_data)['encoding']
            return encoding is not None
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return False

def find_text_in_files(folder_path, search_text):
    results = []
    for root, dirs, files in os.walk(folder_path):
        for file_name in files:
            file_path = os.path.join(root, file_name)
            if is_text_file(file_path):
                lines = read_text_file(file_path, chardet.detect(open(file_path, 'rb').read())['encoding'])
                for line_number, line in enumerate(lines, 1):
                    if search_text in line:
                        results.append((file_path, line_number, line.strip()))
    return results

# 提示用户输入所需的参数
parent_folder = input("请输入要搜索的父文件夹路径：")
search_text = input("请输入要搜索的文本：")
print('正在搜索...')

# 执行搜索指定文本的操作
search_results = find_text_in_files(parent_folder, search_text)

# 显示搜索结果
if search_results:
    print(f"搜索到 {len(search_results)} 处匹配：")
    for file_path, line_number, line_content in search_results:
        print(f"文件：{file_path}，行数：{line_number}，内容：{line_content}")
else:
    print("未找到匹配的内容。")

input("按任意键退出...")
exit()
----------search.py----------

----------video.py----------

import tkinter as tk
import tkinter.messagebox as msgbox
from tkinter import ttk
from tkinter import filedialog
from urllib import parse
import re
import threading
import webbrowser
import subprocess
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import os


class VideoPlayerApp:
    def __init__(self, width=500, height=300):
        self.w = width
        self.h = height
        self.title = '视频播放器和下载器(下载器成功率过低,请谨慎使用)---(请勿滥用,作者不负任何责任)'
        self.root = tk.Tk(className=self.title)
        self.url = tk.StringVar()
        self.v = tk.IntVar()
        self.v.set(1)
        self.port = 'https://jx.jsonplayer.com/player/?url='
        self.port2 = 'https://jx.2s0.cn/player/?url=' #成功概率最高
        self.port3 = 'https://jx.qqwtt.com/?url='
        self.port4 = 'https://jx.xyflv.cc/?url='  
        self.port5 = 'https://jx.playerjy.com/?url=' 
        self.ip = ''
        self.download_directory = ''
        self.cancel_flag = False  
        self.new_name = tk.StringVar()  

        self.setup_ui()

    def setup_ui(self):
        # Main Frames
        frame_1 = tk.Frame(self.root)
        frame_2 = tk.Frame(self.root)
        download_frame = tk.Frame(self.root)
        rename_frame = tk.Frame(self.root)

        frame_1.pack(pady=10)
        frame_2.pack(pady=10)
        download_frame.pack(pady=10)
        rename_frame.pack(pady=10)

        # Group Label
        group_label = tk.Label(frame_1, text='通道选择：')
        group_label.grid(row=0, column=0, padx=10, pady=10)

        # Radiobutton
        tb1 = tk.Radiobutton(frame_1, text='通道 1', variable=self.v, value=1)
        tb1.grid(row=0, column=1, padx=5)

        tb2 = tk.Radiobutton(frame_1, text='通道 2', variable=self.v, value=2)
        tb2.grid(row=0, column=2, padx=5)

        tb3 = tk.Radiobutton(frame_1, text='通道 3', variable=self.v, value=3)
        tb3.grid(row=0, column=3, padx=5)

        tb4 = tk.Radiobutton(frame_1, text='通道 4', variable=self.v, value=4)
        tb4.grid(row=0, column=4, padx=5)

        tb5 = tk.Radiobutton(frame_1, text='通道 5', variable=self.v, value=5)
        tb5.grid(row=0, column=5, padx=5)
        # Input Label and Entry
        label = tk.Label(frame_2, text='请输入视频链接：')
        entry = tk.Entry(frame_2, textvariable=self.url, highlightcolor='Fuchsia', highlightthickness=1, width=40)
        label.grid(row=0, column=0, padx=(10, 0))
        entry.grid(row=0, column=1)

        # Play Button
        play = tk.Button(frame_2, text='播放', font=('楷体', 12), fg='Purple', width=8, height=1,
                         command=self.video_play)
        play.grid(row=0, column=2, padx=(10, 0))

        # Download Buttons and Progress Bar
        download_button = tk.Button(download_frame, text='下载(只支持b站和通道1)', font=('楷体', 12), fg='Green', width=25,
                                    height=1,
                                    command=self.download_video)
        clear_button = tk.Button(download_frame, text='清空输入', font=('楷体', 12), fg='Red', width=10, height=1,
                                 command=self.clear_input)
        choose_dir_button = tk.Button(download_frame, text='选择下载目录', font=('楷体', 12), fg='Blue', width=15,
                                      height=1,
                                      command=self.choose_download_directory)
        cancel_button = tk.Button(download_frame, text='取消下载', font=('楷体', 12), fg='Red', width=15, height=1,
                                  command=self.cancel_download)

        download_button.grid(row=0, column=0, padx=(10, 0))
        clear_button.grid(row=0, column=1, padx=10)
        choose_dir_button.grid(row=0, column=2, padx=10)
        cancel_button.grid(row=0, column=3, padx=10)

        # Status Label and Progress Bar
        self.status_label = tk.Label(self.root, text='', fg='blue')
        self.status_label.pack(pady=0)
        self.progress_bar = ttk.Progressbar(self.root, mode='indeterminate')
        self.progress_bar.pack(fill='x', padx=10, pady=5)

        # Rename Label and Entry
        rename_label = tk.Label(rename_frame, text='请输入视频新名称：')
        rename_entry = tk.Entry(rename_frame, textvariable=self.new_name, highlightcolor='Fuchsia',
                                highlightthickness=1, width=51)
        rename_label.grid(row=0, column=0, padx=(10, 0))
        rename_entry.grid(row=0, column=1)

    def show_status_message(self, message):
        self.status_label.config(text=message)

    def clear_input(self):
        self.url.set('')  # Clear the input field

    def choose_download_directory(self):
        self.download_directory = filedialog.askdirectory()  # Open a file dialog to choose the download directory

    def cancel_download(self):
        self.cancel_flag = True

    def update_progress_bar(self, value):
        self.progress_bar["value"] = value

    def video_play(self):
        url = self.url.get()
        if re.match(r'^https?://\w.+$', url):
            self.ip = parse.quote_plus(url)
            if self.v.get() == 1:  # 根据选中的通道播放视频
                webbrowser.open(self.port + self.ip)
            elif self.v.get() == 2:
                webbrowser.open(self.port2 + self.ip)
            elif self.v.get() == 3:
                webbrowser.open(self.port3 + self.ip)
            elif self.v.get() == 4:
                webbrowser.open(self.port4 + self.ip)
            elif self.v.get() == 5:
                webbrowser.open(self.port5 + self.ip)
        else:
            msgbox.showerror(title='错误', message='视频链接地址无效，请重新输入！')

    def download_video(self):
        url = self.url.get()
        if re.match(r'^https?://\w.+$', url):
            self.ip = parse.quote_plus(url)
            download_thread = threading.Thread(target=self.download_video_thread)
            download_thread.start()
            self.show_status_message('开始下载视频...')
        else:
            msgbox.showerror(title='错误', message='视频链接地址无效，请重新输入！')

    def download_video_thread(self):
        try:
            options = Options()
            options.add_argument('--headless')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument("--window-size=1920,1080")
            options.add_argument(
                "user-agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'")

            driver = webdriver.Chrome(options=options)
            driver.get(self.port + self.ip)
            wait = WebDriverWait(driver, 10)
            video_element = wait.until(
                EC.presence_of_element_located((By.XPATH, '//div[@class="yzmplayer-video-wrap"]//video')))
            src_url = video_element.get_attribute("src")
            driver.quit()

            self.video_url = src_url
            video_url = self.video_url

            if not self.download_directory:
                msgbox.showerror(title='错误', message='请选择下载目录！')
                return

            self.update_progress_bar(0)
            self.cancel_flag = False

            # Start the download
            output_dir = self.download_directory
            subprocess.run(['you-get', '-o', output_dir, video_url])

            self.rename_video()
            self.show_status_message('视频下载已完成！')

        except Exception as e:
            print(e)
            self.show_status_message('下载视频出错，请重试。')

    def rename_video(self):
        if self.new_name.get():
            new_name = self.new_name.get() + '.mp4'
            if self.download_directory and os.path.exists(self.download_directory):
                files = os.listdir(self.download_directory)
                for file in files:
                    if file.endswith('.mp4'):
                        old_path = os.path.join(self.download_directory, file)
                        new_path = os.path.join(self.download_directory, new_name)
                        os.rename(old_path, new_path)
                        break

    def loop(self):
        self.root.resizable(True, True)
        self.root.mainloop()


if __name__ == "__main__":
    app = VideoPlayerApp()
    app.loop()

"""
可用的其它解析地址：
https://vip.yeyulingfeng.com/
"""

----------video.py----------

----------install.bat----------

python -m ensurepip --default-pip

pip install requests
pip install jsonpath-ng
pip install beautifulsoup4
pip install pillow
pip install chardet
pip install selenium

pause

----------install.bat----------